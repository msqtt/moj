package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.49

import (
	"context"
	"errors"
	"log/slog"
	red_pb "moj/apps/record/rpc"
	user_pb "moj/apps/user/rpc"
	"moj/apps/web-bff/graph/model"
	"moj/apps/web-bff/middleware"
	"moj/apps/web-bff/pkg"
	"moj/apps/web-bff/token"

	"google.golang.org/grpc/codes"
	gstatus "google.golang.org/grpc/status"
)

// Login is the resolver for the login field.
func (r *mutationResolver) Login(ctx context.Context, input model.LoginInput) (*model.LoginResult, error) {
	// r.RpcClients.UserClient.
	agent, err := middleware.GetClientAgentFromContext(ctx)
	if err != nil {
		slog.Error("get client agent error", "err", err)
		agent = "unknown"
	}
	ip, err := middleware.GetClientIpFromContext(ctx)
	if err != nil {
		slog.Error("get client ip error", "err", err)
		ip = "unknown"
	}
	req := &user_pb.LoginRequest{
		Email:    input.Email,
		Password: input.Password,
		Device:   agent,
		IpAddr:   ip,
	}

	resp, err := r.RpcClients.UserClient.Login(ctx, req)
	if err != nil {
		slog.Error("login user error", "err", err)
		if stat, ok := gstatus.FromError(err); ok {
			switch stat.Code() {
			case codes.InvalidArgument:
				return nil, ErrLoginPasswordWrong
			case codes.NotFound:
				return nil, ErrLoginAccountNotFound
			default:
			}
		}
		return nil, ErrInternal
	}

	mod, err := findUser(r.RpcClients.UserClient, ctx, resp.AccountID)
	if err != nil {
		slog.Error("login: find user error", "err", err)
		return nil, err
	}

	accessToken, err := r.sessionManager.GenerateAccessToken(resp.AccountID)
	if err != nil {
		slog.Error("generate access token error", "err", err)
		return nil, ErrInternal
	}
	refreshToken, err := r.sessionManager.GenerateRefreshToken(resp.AccountID)
	if err != nil {
		slog.Error("generate refresh token error", "err", err)
		return nil, ErrInternal
	}

	return &model.LoginResult{
		Token: &model.Token{
			RefreshToken: refreshToken,
			AccessToken:  accessToken,
		},
		User: mod,
	}, nil
}

// Register is the resolver for the register field.
func (r *mutationResolver) Register(ctx context.Context, input model.RegisterInput) (*model.User, error) {
	req := &user_pb.RegisterRequest{
		Email:    input.Email,
		NickName: input.NickName,
		Password: input.Password,
		Captcha:  input.Captcha,
	}

	resp, err := r.RpcClients.UserClient.Register(ctx, req)
	if err != nil {
		slog.Error("register user error", "err", err)
		if status, ok := gstatus.FromError(err); ok {
			switch status.Code() {
			case codes.InvalidArgument:
				return nil, errors.Join(ErrRegisterInvaild, err)
			case codes.NotFound:
				return nil, ErrCaptchaNotFound
			case codes.DeadlineExceeded:
				return nil, ErrCaptchaNotFound
			case codes.AlreadyExists:
				return nil, ErrRegisterAccountExists
			default:
			}
		}
		return nil, ErrInternal
	}

	user, err := findUser(r.RpcClients.UserClient, ctx, resp.AccountID)
	if err != nil {
		slog.Error("register: find user error", "err", err)
		return nil, err
	}

	return user, err
}

// ModifyUserInfo is the resolver for the updateUserInfo field.
func (r *mutationResolver) ModifyUserInfo(ctx context.Context, info *model.UserInfo) (*model.User, error) {
	_, err := checkUserLogin(r.RpcClients.UserClient, r.sessionManager, ctx, info.ID, false)
	if err != nil {
		return nil, err
	}

	req := &user_pb.UpdateUserInfoRequest{
		AccountID:  info.ID,
		NickName:   info.NickName,
		AvatarLink: info.AvatarLink,
	}
	_, err = r.RpcClients.UserClient.UpdateUserInfo(ctx, req)
	if err != nil {
		slog.Error("update user info error", "err", err)
		if status, ok := gstatus.FromError(err); ok {
			switch status.Code() {
			case codes.NotFound:
				return nil, ErrUserNotFound
			case codes.InvalidArgument:
				return nil, errors.Join(ErrUserInfoInvalid, err)
			default:
			}
		}
		return nil, ErrInternal
	}

	user, err := findUser(r.RpcClients.UserClient, ctx, info.ID)
	if err != nil {
		slog.Error("update user info: find user error", "err", err)
		return nil, err
	}

	return user, err
}

// ChangePassword is the resolver for the changePassword field.
func (r *mutationResolver) ChangePassword(ctx context.Context, input *model.ChangePasswordInput) (*model.User, error) {
	_, err := checkUserLogin(r.RpcClients.UserClient, r.sessionManager, ctx, input.ID, false)
	if err != nil {
		return nil, err
	}

	user, err := findUser(r.RpcClients.UserClient, ctx, input.ID)
	if err != nil {
		slog.Error("change password 1: find user error", "err", err)
		return nil, err
	}

	req := &user_pb.ChangeUserPasswordRequest{
		AccountID: input.ID,
		Email:     user.Email,
		Password:  input.NewPassword,
		Captcha:   input.Captcha,
	}

	_, err = r.RpcClients.UserClient.ChangeUserPassword(ctx, req)
	if err != nil {
		slog.Error("change password: change user password error", "err", err)
		if status, ok := gstatus.FromError(err); ok {
			switch status.Code() {
			case codes.InvalidArgument:
				return nil, ErrChangePasswdInvalid
			case codes.NotFound:
				return nil, ErrCaptchaNotFound
			default:
			}
		}
		return nil, ErrInternal
	}

	user, err = findUser(r.RpcClients.UserClient, ctx, input.ID)
	if err != nil {
		slog.Error("change password 2: find user error", "err", err)
		return nil, err
	}

	return user, err
}

// DeleteUser is the resolver for the deleteUser field.
func (r *mutationResolver) DeleteUser(ctx context.Context, id string) (*model.Time, error) {
	_, err := checkUserLogin(r.RpcClients.UserClient, r.sessionManager, ctx, id, false)
	if err != nil {
		return nil, err
	}

	req := &user_pb.DeleteUserRequest{
		AccountID: id,
	}
	resp2, err := r.RpcClients.UserClient.DeleteUser(ctx, req)
	if err != nil {
		slog.Error("delete user info error", "err", err)
		if status, ok := gstatus.FromError(err); ok {
			switch status.Code() {
			case codes.NotFound:
				return nil, ErrUserNotFound
			case codes.AlreadyExists:
				return nil, ErrDeleteUserDuplicated
			default:
			}
		}
		return nil, ErrInternal
	}
	return fromInt64Second(resp2.GetTime()), err
}

// SetUserStatus is the resolver for the setUserStatus field.
func (r *mutationResolver) SetUserStatus(ctx context.Context, id string, status bool) (*model.User, error) {
	_, err := checkUserLogin(r.RpcClients.UserClient, r.sessionManager, ctx, id, true)
	if err != nil {
		return nil, err
	}

	req := &user_pb.SetStatusRequest{
		AccountID: id,
		Enabled:   status,
	}
	_, err = r.RpcClients.UserClient.SetStatus(ctx, req)
	if err != nil {
		slog.Error("set user status error", "err", err)
		if status, ok := gstatus.FromError(err); ok {
			switch status.Code() {
			case codes.NotFound:
				return nil, ErrUserNotFound
			default:
			}
		}
		return nil, ErrInternal
	}

	user, err := findUser(r.RpcClients.UserClient, ctx, id)
	if err != nil {
		slog.Error("set user status: get user error", "err", err)
		return nil, err
	}

	return user, err
}

// SetUserAdmin is the resolver for the setUserAdmin field.
func (r *mutationResolver) SetUserAdmin(ctx context.Context, id string, isAdmin bool) (*model.User, error) {
	_, err := checkUserLogin(r.RpcClients.UserClient, r.sessionManager, ctx, id, true)
	if err != nil {
		return nil, err
	}

	req := &user_pb.SetAdminRequest{
		AccountID: id,
		IsAdmin:   isAdmin,
	}

	_, err = r.RpcClients.UserClient.SetAdmin(ctx, req)
	if err != nil {
		slog.Error("set user status error", "err", err)
		if status, ok := gstatus.FromError(err); ok {
			switch status.Code() {
			case codes.NotFound:
				return nil, ErrUserNotFound
			default:
			}
		}
		return nil, ErrInternal
	}

	user, err := findUser(r.RpcClients.UserClient, ctx, id)
	if err != nil {
		slog.Error("set user status: get user error", "err", err)
		return nil, err
	}

	return user, err
}

// FetchAccessToken is the resolver for the fetchAccessToken field.
func (r *mutationResolver) FetchAccessToken(ctx context.Context, refreshToken string) (*model.Token, error) {
	id, err := r.sessionManager.ValidRefreshToken(refreshToken)
	if err != nil {
		slog.Error("refresh token invalid", "err", err)
		err = errors.Join(ErrUserTokenInvalid, err)
		return nil, err
	}

	token, err := r.sessionManager.GenerateAccessToken(id)
	if err != nil {
		slog.Error("generate access token invalid", "err", err)
		return nil, ErrInternal
	}

	return &model.Token{
		RefreshToken: refreshToken,
		AccessToken:  token,
	}, err
}

// User is the resolver for the user field.
func (r *queryResolver) User(ctx context.Context, id string) (user *model.User, err error) {
	_, err1 := checkUserLogin(r.RpcClients.UserClient, r.sessionManager, ctx, id, false)
	if err1 != nil {
		_, err2 := checkUserLogin(r.RpcClients.UserClient, r.sessionManager, ctx, "", true)
		if err2 != nil {
			user = nil
			err = err2
			return
		}
	}
	user, err = findUser(r.RpcClients.UserClient, ctx, id)
	if err != nil {
		slog.Error("get user error", "err", err)
	}
	return
}

// Users is the resolver for the users field.
func (r *queryResolver) Users(ctx context.Context, pageSize int, afterID *string, filter *model.UsersFilter) (*model.UserPage, error) {
	_, err := checkUserLogin(r.RpcClients.UserClient, r.sessionManager, ctx, "", true)
	if err != nil {
		return nil, err
	}

	var cursor string
	if afterID == nil {
		cursor = ""
	} else {
		cursor = *afterID
	}

	var filterOptions *user_pb.GetUserPageRequest_Option
	if filter != nil {
		filterOptions = &user_pb.GetUserPageRequest_Option{
			Word:    filter.Word,
			Enabled: filter.Enabled,
			IsAdmin: filter.IsAdmin,
		}
	}

	resp, err := r.RpcClients.UserClient.GetUserPage(ctx, &user_pb.GetUserPageRequest{
		Cursor:        cursor,
		PageSize:      int32(pageSize),
		FilterOptions: filterOptions,
	})
	if err != nil {
		slog.Error("get user page error", "err", err)
		return nil, ErrInternal
	}

	users := make([]*model.User, len(resp.GetUsers()))
	for id, u := range resp.GetUsers() {
		users[id] = fromProtoUser(u)
	}

	return &model.UserPage{
		Users:  users,
		NextID: resp.NextCursor,
	}, err
}

// FinishedQuestion is the resolver for the finishedQuestion field.
func (r *userResolver) FinishedQuestion(ctx context.Context, obj *model.User) (*model.FinishedQuestion, error) {
	resp, err := r.RpcClients.RecordClient.GetAccountPassedCount(ctx, &red_pb.GetAccountPassedCountRequest{
		AccountID: obj.ID,
	})
	if err != nil {
		slog.Error("get account passed count error", "err", err)
		if status, ok := gstatus.FromError(err); ok && status.Code() == codes.NotFound {
			return nil, ErrUserNotFound
		}
		return nil, ErrInternal
	}
	return &model.FinishedQuestion{
		EazyCount:   int(resp.Eazy),
		NormalCount: int(resp.Normal),
		HardCount:   int(resp.Hard),
	}, err
}

// User returns UserResolver implementation.
func (r *Resolver) User() UserResolver { return &userResolver{r} }

type userResolver struct{ *Resolver }

// !!! WARNING !!!
// The code below was going to be deleted when updating resolvers. It has been copied here so you have
// one last chance to move it out of harms way if you want. There are two reasons this happens:
//   - When renaming or deleting a resolver the old code will be put in here. You can safely delete
//     it when you're done.
//   - You have helper methods in this file. Move them out to keep these resolver files clean.
func fromInt64Second(i int64) *model.Time {
	return &model.Time{Time: pkg.Int64ToString(i)}
}
func checkUserLogin(client user_pb.UserServiceClient, smg *token.SessionManager,
	ctx context.Context, limitID string, needAdmin bool) (loginID string, err error) {
	tokn, err := middleware.GetAuthTokenFromContext(ctx)
	if err != nil {
		slog.Error("check user login error", "err", err)
		err = errors.Join(ErrUserUnLogined, err)
		return
	}

	loginID, err = smg.ValidAccessToken(tokn)
	if err != nil {
		slog.Error("check user login error", "err", err)
		err = errors.Join(ErrUserTokenInvalid, err)
		return
	}

	if !needAdmin && limitID == "" {
		return
	} else if !needAdmin && loginID != limitID {
		err = ErrUserUnAuthorized
		return
	} else if !needAdmin && loginID == limitID {
		return
	}
	// else needAdmin
	resp, err := client.GetUser(ctx, &user_pb.GetUserRequest{
		AccountID: loginID,
	})
	if err != nil {
		if status, ok := gstatus.FromError(err); ok && status.Code() == codes.NotFound {
			err = ErrUserUnAuthorized
			return
		}
		err = ErrInternal
		return
	}
	if !resp.User.IsAdmin {
		err = ErrUserUnAuthorized
		return
	}
	return
}
func findUser(client user_pb.UserServiceClient, ctx context.Context, id string) (*model.User, error) {
	resp, err := client.GetUser(ctx, &user_pb.GetUserRequest{
		AccountID: id,
	})
	if err != nil {
		if status, ok := gstatus.FromError(err); ok {
			switch status.Code() {
			case codes.NotFound:
				return nil, ErrUserNotFound
			default:
			}
		}
		return nil, ErrInternal
	}

	return fromProtoUser(resp.User), err
}
func fromProtoUser(u *user_pb.User) *model.User {
	return &model.User{
		ID:                   u.AccountID,
		Email:                u.Email,
		AvatarLink:           u.AvatarLink,
		NickName:             u.NickName,
		Enabled:              u.Enabled,
		IsAdmin:              u.IsAdmin,
		LastLoginTime:        pkg.Int64ToString(u.LastLoginTime),
		LastLoginIPAddr:      u.LastLoginIPAddr,
		LastLoginDevice:      u.LastLoginDevice,
		LastPasswdChangeTime: pkg.Int64ToString(u.LastPasswdChangeTime),
		RegisterTime:         pkg.Int64ToString(u.RegisterTime),
		DeleteTime:           pkg.Int64ToString(u.DeleteTime),
	}
}

var (
	ErrUserTokenInvalid      = errors.New("用户 Token 无效")
	ErrUserUnAuthorized      = errors.New("用户操作未授权")
	ErrUserUnLogined         = errors.New("用户未登录")
	ErrDeleteUserDuplicated  = errors.New("用户重复删除")
	ErrUserNotFound          = errors.New("用户不存在")
	ErrUserInfoInvalid       = errors.New("用户信息错误")
	ErrChangePasswdInvalid   = errors.New("输入密码格式错误")
	ErrRegisterInvaild       = errors.New("注册信息错误")
	ErrCaptchaNotFound       = errors.New("输入验证码错误或已过期")
	ErrRegisterAccountExists = errors.New("注册账户已存在")
	ErrLoginAccountNotFound  = errors.New("登录账户不存在")
	ErrLoginPasswordWrong    = errors.New("登录账户密码错误")
	ErrInternal              = errors.New("服务器内部错误")
)
